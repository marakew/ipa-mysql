.\" Copyright (c) 2001-2003 Andrey Simonenko
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\" @(#)$Id: ipa.conf.5,v 1.4.2.5 2003/07/08 08:30:05 simon Exp $
.\"
.TH IPA.CONF 5 "July 2, 2003"
.SH NAME
ipa.conf \- конфигурационный файл для ipa(8)
.SH DESCRIPTION
Файл \fBipa.conf\fP это конфигурационный файл для \fBipa\fP(8).
Файл \fB/usr/local/etc/ipa.conf\fP или любой-другой файл,
определённый в командной строке \fBipa\fP(8) (опция \fB-f\fP),
обрабатывается когда \fBipa\fP(8) начинает работать или получает
сигнал HUP. Полное описание формата этого файла и описание всех
параметров доступны на данной man-странице.
.SH FILE FORMAT
Формат файла \fBipa.conf\fP может быть достаточно простым и довольно сложным.
Главная идея заключается в расположении как можно большего числа функций учёта
в одном конфигурационном файле, для того чтобы не использовать внешние скрипты.
.PP
Если вы впервые работаете с \fBipa\fP(8), то прочтите этот раздел man-страницы
от первой строки до последней. Эта man-страница не только описание формата конфигурационного
файла, но и полная документация о всех возможностях \fBipa\fP(8), возможных
ошибках и step by step документация как заставить \fBipa\fP(8) работать должным
образом.
.PP
Конфигурационный файл состоит из секций и параметров. Каждая секция начинается
с указания типа секции, далее имени секции и открывающей фигурной скобки или
просто открывающей фигурной скобки. Каждая секция должна быть где-то закрыта
закрывающей фигурной скобкой:
.PP
	тип-секции [имя-секции] {
.br
	# параметры и другие секции
.br
	}
.PP	
Секции содержат параметры. Большинство параметров имеют следующую форму:

	параметр[(аргумент(ы))] = значение
.PP
Все элементы в конфигурационном файле регистрозависимые.
.PP
Любая строка начинающаяся с символа фунта `#' или с символа `;' игнорируется,
как и строки состоящие только из пробельных символов (` ' и `\(rst') и пустые
строки, но см. предложение ниже.
.PP
Любая строка заканчивающаяся символом `\(rs' рассматривается как строка имеющая
продолжение в следующей строке. Если символ `\(rs' необходим в конце строки, но
не должен обозначать символ продолжения, то добавьте пробельный символ после
него.
.PP
Если в каком-то месте в строке допускается использование одного пробельного
символа, то можно использовать столько пробельных символов, сколько необходимо
для улучшения форматирования конфигурационного файла.
.PP
Теоретически длина строки в конфигурационном файле не ограничена. В реализации
длина строки ограничена максимальным значением C-типа "int".
.PP
Некоторые секции не должны включаться внутри других секций, некоторые секции
наоборот могут только быть использованы внутри других. Есть четыре секции, которые
всегда должны располагаться отдельно: \fBdebug\fP, \fBinclude\fP, \fBglobal\fP,
и \fBrule\fP. Конфигурационный файл может вообще не содержать ни одной секции,
он может быть даже пустым файлом.
.PP
\fBipa\fP(8) позволяет делать учёт IP трафика на основании параметров,
определённых в правилах перечисленных в конфигурационном файле. Секция
\fBrule\fP имеет следующий формат:
.PP
	rule <имя-правила> {
.br
	# параметры и другие секции
.br
	}
.PP
<имя-правила> это строка без пробельных символов, без символов `{', `}', `#'
и символа `;'. Следует давать имя для правила такое, чтобы это имя было
корректным именем для директории в вашей операционной/файловой системе, т.к.
каждое правило представляется директорией в базе данных.
.PP
Секция \fBrule\fP должна содержать по крайней мере \fBipfw\fP, \fBip6fw\fP,
\fBpf\fP или \fBipfil\fP параметр. Все остальные параметры могут отсутствовать.
Параметры \fBipfw\fP, \fBip6fw\fP и \fBipfil\fP являются главными параметрами
для учёта IP трафика, они определяют номера учётных правил FreeBSD IPv4 Firewall
(IPFW), FreeBSD IPv6 Firewall (IP6FW), OpenBSD Packet Filter (PF) и IP Filter
(IPF), из которых \fBipa\fP(8) берёт статистику. Эти параметры могут
использоваться совместно в одном и той же секции \fBrule\fP.
.PP
Параметр \fBipfw\fP имеет следующий формат:
.PP
	ipfw = [-]номер[.подномер]
.PP
Возможно использовать имя \fBip4fw\fP для параметра \fBipfw\fP. Оба имени
правильны и ссылаются на FreeBSD IPv4 Firewall или просто FreeBSD IP Firewall.
.PP
В оригинальном формате правила IPFW присутствует только один номер правила.
Дополнительный подномер может быть использован в следующей ситуации: если
существует несколько IPFW правил с одинаковым номером, то такие правила
различаются по подномерам, первое правило в списке имеет подномер равный 0.
Если подномер не указан, то он считается равным 0. Понятие "подномер"
в IPFW правиле является новым и не упоминается на man-странице ipfw(8). Перед
номером IPFW правила может быть поставлен знак `\fB-\fP', в этом случае
\fBipa\fP(8) будет вычитать учётную информацию для этого правила IPFW.
.PP
Пример:
.PP
	ipfw = 100 130.2 -150.1 20
.br
	ipfw = 100.0
.PP
Если в секции \fBrule\fP присутствуют несколько \fBipfw\fP параметров, то они
рассматриваются как один параметр \fBipfw\fP.
.PP
Параметр \fBip6fw\fP имеет такой-же формат что и формат параметра \fBipfw\fP.
.PP
Параметр \fBipfil\fP имеет следующий формат:
.PP
	ipfil = [-]i[группа]@номер
.br
	ipfil = [-]o[группа]@номер
.PP
Символ `\fBi\fP' используется для "count in", а символ `\fBo\fP' используется
для "count out" списка правил IPF. Все правила в IPF принадлежат каким-то
группам и имеют порядковые номера в группах (подробная информация об этом
доступна на man-странице ipf(5)). Если номер группы не указан в параметре
\fBipfil\fP, то номер группы считается равным 0 (номер группы по умолчанию в
IPF). Первое правило IPF в группе имеет номер 1. Такой тип нумерации IPF
правил взят из программы ipfstat(8) и из man-страницы ipf(5). Символ `\fB-\fP'
может быть записан перед номером правила, в этом случае \fBipa\fP(8) будет
вычитать учётную информацию для этого правила IPF.
.PP
Пример:
.PP
	ipfil = o@10 o1@5
.br
	ipfil = -i12@4 o@2 o40@10
.PP
Если в секции \fBrule\fP присутствует несколько \fBipfil\fP параметров, то они
рассматриваются как один параметр \fBipfil\fP.
.PP
Номера правил IPF и номера их групп могут быть получены из вывода
команды "ipfstat -iona".
.PP
Параметр \fBpf\fP имеет следующий формат:
.PP
	pf = [-]номер
.PP
Пример:
.PP
	pf = 1 -8 3
.br
	pf = 100
.PP
Если в секции \fBrule\fP присутствуют несколько \fBpf\fP параметров, то они
рассматриваются как один параметр \fBpf\fP.
.PP
\fBipa\fP(8) использует C-тип u_quad_t (unsigned long long) для хранения
статистики (т.е. счётчиков
байтов). Тип u_quad_t это беззнаковое 64-битовое целое, максимальное значение
которого равно 16777216\ Tбайт\ -\ 1\ байт (или значение UQUAD_MAX). Эта величина
достаточна для большинства целей, но \fBipa\fP(8) может определить когда это
значение переполняется и добавляет новую запись в базу данных в этом случае.
Каждая запись в базе данных состоит из двух полей. Первое поле состоит из двух
временных отметок: когда запись была добавлена в базу данных и когда запись
была  изменена в последний раз. Временная отметка состоит из номера дня и
времени (часы, минуты, секунды). Второе поле это счётчик байтов. Подробно о
реализации базы данных можно прочитать на man-странице \fBipa\fP(5).
.PP
\fBipa\fP(8) может не только суммировать, но и вычитать значения счётчиков
(знак `\fB-\fP' в \fBipfw\fP, \fBip6fw\fP, \fBipfil\fP и \fBpf\fP параметрах).
Обычно вычитаемые счётчики правил IPFW/IPF/PF являются частями суммируемых
счётчиков правил IPFW/IPF/PF в той же секции \fBrule\fP. Но если необходимо
вычитать больше байтов чем текущее значение счётчика в секции \fBrule\fP, то это
значение \fBipa\fP(8) запоминает в своей внутренней структуре и обнуляет значение
счётчика для этого правила. \fINOTE\fP: \fBipa\fP(8) может запомнить не более
чем UQUAD_MAX байт, которые необходимо вычесть, если количество байтов, которые
необходимо вычитать больше чем UQUAD_MAX, то \fBipa\fP(8) выдаст предупреждающее
сообщение. Вы вероятно никогда не увидите такое сообщение в вашем log-файле
(значение UQUAD_MAX слишком велико), поэтому следует проверять правильно ли
записаны вычитаемые IPFW/IPF/PF правила. \fINOTE\fP: вычитаемые байты не
сохраняются в базе данных (эта фраза имеет только смысл, если необходимо
вычитать больше байтов, чем содержится в счётчике байтов для правила).
.PP
Следующие два параметра определяют время добавления новой записи в базу данных
и время обновления счётчика байтов в базе данных. Значения этих параметров
полезны для программы \fBipastat\fP(8). \fBipastat\fP(8) использует только
информацию из базы данных и эта информация должна быть не устаревшей, также эти
два параметра позволяют увеличить вероятность сохранности базы данных если
система даст сбой.
.PP
Параметр \fBupdate_db_time\fP определяет время когда \fBipa\fP(8) следует
обновить счётчик байтов для правила.
.PP
Параметр \fBupdate_db_time\fP имеет следующий формат:
.PP
	update_db_time = <время>
.PP
Пример:
.PP
	update_db_time = 10s
.br
	update_db_time = 2h30s
.br
	update_db_time = 13h3m 134s
.PP
Символ `\fBs\fP' обозначает секунды, `\fBm\fP' - минуты, `\fBh\fP' - часы.
Если <время> определяется как сложное значение, то часы должны быть указаны
перед минутами и секундами, минуты должны предшествовать секундам. Рассмотрим
третий пример: 134 секунды это 2 минуты и 14 секунд, это не ошибка, но лучше
всего запустить \fBipa\fP(8) с опцией \fB-t\fP и проверить вывод (возможно вы
сделали ошибку и набрали лишнюю цифру).
.PP
Если параметр \fBupdate_db_time\fP не указан, то используется значение этого же
параметра из секции \fBglobal\fP. Если и тот параметр не указан, тогда
используется значение по умолчанию, равное 5 минутам.
.PP
\fINOTE\fP: если какое-то из IPFW/IPF/PF правил указанных в секции \fBrule\fP
являются достаточно "быстрыми", тогда неправильное значение параметра \fBupdate_db_time\fP
может привести к неправильным результатам учёта. Например update_db_time\ =\ 1h,
а одно из IPFW правил подсчитывает байты одного очень быстрого соединения. Когда
\fBipa\fP(8) начала подсчитывать байты для этого IPFW правила, счётчик был равен 1-му
байту. В течении 1-го часа счётчик стал равным (1\ +\ UQUAD_MAX\ +\ 1) байтам. Когда
\fBipa\fP(8) в очередной раз проверяет это IPFW правило, то обнаруживается, что
текущее значение счётчика стало 2\ байта\ -\ 1\ байт\ =\ 1\ байт. Что является ошибкой.
Чтобы исправить эту проблему, следует установить значение параметра \fBupdate_db_time\fP
так, чтобы за заданный промежуток времени ни одно из IPFW/IPF/PF правил в
секции \fBrule\fP не могло быть переполнено.
.PP
Параметр \fBappend_db_time\fP определяет время, когда \fBipa\fP(8) следует
добавить новую запись в базу данных.
.PP
Параметр \fBappend_db_time\fP имеет следующий формат:
.PP
	append_db_time = <время>
.PP
Пример:
.PP
	append_db_time = 2h
.PP
Это определение позволяет делать учёт IP трафика за каждые два часа.
.PP
Если параметр \fBappend_db_time\fP не указан, то используется значение этого же
параметра из секции \fBglobal\fP. Если и тот параметр не указан, тогда нет
значения по умолчанию и новая запись добавляется в начале следующего дня.
Это также справедливо, если параметр \fBappend_db_time\fP указан в секции
\fBrule\fP или в секции \fBglobal\fP.
.PP
Обычно значение параметра \fBappend_db_time\fP больше значения параметра
\fBupdate_db_time\fP. Но если значение параметра \fBappend_db_time\fP меньше,
то предупреждения насчёт параметра \fBupdate_db_time\fP где-либо в этой
man-странице также верны и для параметра \fBappend_db_time\fP.
.PP
\fBipa\fP(8) может вести статистику не только для всех дней в неделе, но и
для конкретных периодов. Параметр \fBworktime\fP определяет временные
интервалы, когда \fBipa\fP(8) следует выполнять учёт трафика для правила.
Если параметр \fBworktime\fP не указан в секции \fBrule\fP, то
используется значение этого же параметра из секции \fBglobal\fP.
Если и тот параметр не указан, тогда учёт трафика производится для
всех дней недели.
.PP
Параметр \fBworktime\fP имеет следующий формат:
.PP
	worktime = <X> h1:m1-h2:m2 [h1:m1-h2:m2]
.br
	worktime = <X> *
.PP
<X> обозначает день недели. Доступные значения для <X> следующие:
`\fBS\fP' обозначает воскресенье, `\fBM\fP' - понедельник,
`\fBT\fP' - вторник, `\fBW\fP' - среда, `\fBH\fP' - четверг,
`\fBF\fP' - пятница, `\fBA\fP' - суббота. В формате каждый день может
быть указан только один раз. Временные интервалы не могут перекрываться,
или располагаться в неправильном порядке дней недели.
.PP
Всякий раз, когда начинается новый временной интервал, в базу данных
для правила добавляется новая учётная запись.
.PP
Пример:
.PP
	worktime = M * T * W *
.br
	worktime = H 08:00-14:30 18:20-21:00 S 00:00-10:35
.PP
Первый параметр указывает \fBipa\fP(8) производить учёт трафика только по понедельникам,
вторникам и средам. Второй параметр указывает \fBipa\fP(8) производить учёт трафика
по четвергам с 8:00 до 14:30 и с 18:20 до 21:00, а также по воскресеньям с
полночи до 10:35.
.PP
\fINOTE\fP: если требуется указать весь день, то используйте символ `\fB*\fP' или
временной интервал 00:00-24:00, так как интервалы 00:00-23:59 и 00:00-00:00
ошибочны. В первом случае теряется 1 минута с 23:59 до 00:00 (следующего
дня). Во втором случае теряется весь день.
.PP
Если в секции присутствует несколько \fBworktime\fP параметров, то они
рассматриваются как один параметр \fBworktime\fP.
.PP
\fINOTE\fP: существуют программы на подобии date(1) или ntpdate(8), которые могут
менять время UTC и локальное время, временные зоны могут меняться вообще сами по
себе. Как описано в man-странице \fBipa\fP(5), это может вызвать ошибку для
\fBipa\fP(8). Значения параметров \fBupdate_db_time\fP, \fBappend_db_time\fP и
\fBworktime\fP могут повысить частоту возникновения таких ошибок. Например,
если вы вызываете ntpdate(8) очень часто и значение параметра \fBupdate_db_time\fP
равно периодичности вызова ntpdate(8), то вы можете получить множество ошибок
непоследовательного изменения времени от \fBipa\fP(8).
.PP
Параметр \fBmaxchunk\fP позволяет безопасно обнулять значения правил IPFW/IPF/PF,
или удалять и добавлять одни и те же правила, когда \fBipa\fP(8) запущена.
.PP
Параметр \fBmaxchunk\fP имеет следующий формат:
.PP
	maxchunk = <размер>
.PP
Если новое значение байтового счётчика для какого-то IPFW/IPF/PF правила
меньше чем предыдущее его значение и не указан параметр \fBmaxchunk\fP, то
\fBipa\fP(8) рассматривает эту ситуацию, как переполнение байтового счётчика
IPFW/IPF/PF правила и вычисляет соответствующее значения в качестве
прироста счётчика. Но если указан параметр \fBmaxchunk\fP и прирост байтового
счётчика для какого-то IPFW/IPF/PF правила больше чем значение параметра
\fBmaxchunk\fP, то \fBipa\fP(8) берёт в качестве прироста счётчика его абсолютное
значение.
.PP
Если параметр \fBmaxchunk\fP в секции \fBrule\fP не указан, то используется
значение этого же параметра из секции \fBglobal\fP. Если и тот параметр не
указан, тогда нет значения по умолчанию для этого параметра и если какое-то
IPFW/IPF/PF правило будет обнулено или удалено и добавлено, то \fBipa\fP(8)
может рассмотреть эту ситуацию как переполнение байтового счётчика.
.PP
Пример:
.PP
	maxchunk = 1T 20G 2M 100k 9b
.br
	maxchunk = 1M
.br
	maxchunk = 1G 100k
.PP
Символ `\fBT\fP' или `\fBt\fP' обозначает Тбайты, `\fBG\fP` или `\fBg\fP' -
Гбайты, `\fBM\fP' или `\fBm\fP' - Мбайты, `\fBK\fP' или `\fBk\fP' -
Кбайты, `\fBB\fP' или `\fBb\fP' - байты. Если <размер> определён как сложное
значение, то Тбайты должны следовать перед Гбайтами и Мбайтами и т.д.
.PP
\fINOTE\fP: слишком малое значение параметра \fBmaxchunk\fP может дать неправильные
результаты. Значение параметра \fBmaxchunk\fP должно быть больше чем разница счётчиков
байтов для любого из IPFW/IPF/PF правил за промежуток времени
\fBupdate_db_time\fP секунд.
.PP
\fINOTE\fP: было бы лучше проверять значения полей структур IPFW/IPF/PF в
ядре системы и определять были ли эти правила изменены. Но таких полей в
структурах IPFW/IPF/PF в ядре нет (по крайней мере на момент написания этой
man-страницы), поэтому приходится использовать параметр \fBmaxchunk\fP.
.PP
Директория (включая все директории и файлы в ней) для каждого правила
в базе данных может быть защищена при помощи бит прав доступа.
"Остальным" пользователям не разрешён доступ к директориям и файлам в
базе данных (за исключением файла \fBlock\ db\fP, но если даже
кто-то заблокирует этот файл на долгое время, то это не является
больщой проблемой). Если пользователь принадлежит к группе-владельцу
директории правила, то ему (естественно) разрешён доступ к статистике.
Владельцем всех директорий и файлов в базе данных является
супер-пользователь.
.PP
Праметр \fBdb_group\fP позволяет определить группу пользователей, которым
разрешён доступ к статистике какого-то правила. Когда программа
\fBipa\fP(8) начинает работать (или получает сигнал \fBHUP\fP) она
проверяет группу и биты доступа директорий для всех правил перечисленных
в конфигурационном файле и если существует отличие в группе и/или битах
доступа для какой-то директории и установок в конфигурационном файле
(на самом деле только один параметр \fBdb_group\fP определяет это),
то \fBipa\fP(8) исправляет группу и биты доступа для всех файлов
и директорий в директории правила в базе данных.
.PP
Супер-пользователю всегда разрешён доступ к статистике (система
даёт эту возможность), поэтому нет необходимости указывать какое-либо
значение для параметра \fBdb_group\fP, если вы собираетесь обращаться
к базе данных только с логина супер-пользователя.
.PP
Параметр \fBdb_group\fP имеет следующий формат:
.PP
	db_group = <группа>
.PP
Где <группа> это имя группы или номер группы.
.PP
Пример:
.PP
	db_group = staff
.br
	db_group = 1001
.PP
Если параметр \fBdb_group\fP в секции \fBrule\fP не указан, то используется
значение этого же параметра из секции \fBglobal\fP. Если и тот параметр
не указан, тогда нет значения по умолчанию.
.PP
Секция \fBglobal\fP должна располагаться отдельно и имеет следующий формат:
.PP
	global {
.br
	# параметры
.br
	}
.PP
В секции \fBglobal\fP могут быть указаны только следующие параметры:
\fBupdate_db_time\fP, \fBappend_db_time\fP, \fBmaxchunk\fP, \fBdb_group\fP,
\fBdb_dir\fP, \fBlock_db\fP, \fBworktime\fP, \fBlock_wait_time\fP и
\fBonly_abs_paths\fP.
.PP
Параметры \fBupdate_db_time\fP, \fBappend_db_time\fP, \fBmaxchunk\fP,
\fBworktime\fP и \fBdb_group\fP используются, если одноимённые параметры
упущены в секции \fBrule\fP.
.PP
Параметр \fBdb_dir\fP позволяет изменить заданную по умолчанию директорию
базы данных \fB/var/ipa\fP.
.PP
Параметр \fBdb_dir\fP имеет следующий формат:
.PP
	db_dir = <директория>
.PP
<Директория> должна быть дана в виде абсолютного путевого имени (т.е.
начинаться с `/').
.PP
Обычно существует всего две программы, которые могут одновременно обращаться
к базе данных. Это программы \fBipa\fP(8) и \fBipastat\fP(8). По умолчанию
утилита \fBipa\fP(8) не блокирует никакой файл, который она модифицирует,
а \fBipastat\fP(8) не блокирует никакой файл, к которому она осуществляет
доступ.
.PP
Параметр \fBlock_db\fP позволяет изменить поведение \fBipa\fP(8) в отношении
блокировки, заданное по умолчанию. Он имеет следующий формат:
.PP
	lock_db = <boolean>
.PP
<boolean> может быть "\fByes\fP" или "\fBno\fP". "\fBno\fP" является
значением по умолчанию. Если вы укажете "\fByes\fP", тогда \fBipa\fP(8)
будет блокировать базу данных целиком (блокируется файл \fBlock\ db\fP
в главной директории базы данных), когда она запускается
или перечитывает конфигурационный файл и блокирует записи в файлах
базы данных, когда она обновляет их. \fBipastat\fP(8) будет пытается
заблокировать всю базу данных целиком и необходимые файлы если она запущена
с ключом \fB-L\fP. Если она не сможет получить блокировку в течении 10
секунд, то \fBipastat\fP(8) выводит предупреждающее сообщение и не
обращается к базе данных вовсе.
.PP
Вероятно, вы не захотите включать блокировку базы данных если вы не
используете программу \fBipastat\fP(8) или если вы хотите
предотвратить преднамеренное блокирование файлов базы данных пользователями
(естественно эти пользователи должны иметь доступ к директории правила).
.PP
\fINOTE\fP: если вы не используете блокировку, то \fBipastat\fP(8) иногда
может выдавать сообщения о неправильном формате файлов базы данных, это
означает, что \fBipastat\fP(8) прочитала не полностью обновлённый файл в
базе данных.
.PP
По умолчанию \fBipa\fP(8) ожидает получения блокировки 5 секунд.
Вы можете изменить это при помощи параметра \fBlock_wait_time\fP:
.PP
	lock_wait_time = <время>
.PP
Если \fBipa\fP(8) не сможет получить блокировку в течении \fBlock_wait_time\fP
секунд, то она сообщает об этом и пропускает блокировку.
.PP
По умолчанию \fBipa\fP(8) воспринимает команды заданные в параметрах \fBexec\fP
(см. ниже) только с абсолютными путевыми именами. Параметр \fBonly_abs_paths\fP
(или \fBonly_abs_path\fP) позволяет это изменить:
.PP
	only_abs_paths = <boolean>
.PP
Если вы хотите разрешить использование команд заданных без абсолютных путевых
имён, то установите этот параметр в "\fBno\fP". \fINOTE\fP: \fBipa\fP(8)
обрабатывает конфигурационный файл от первой линии до последней и секцию
\fBglobal\fP следует располагать перед первой секцией \fBrule\fP, если вы
хотите использовать параметр \fBonly_abs_paths\fP.
.PP
Пример секции \fBglobal\fP:
.PP
	global {
.br
	    maxchunk = 10M
.br
	    update_db_time = 30s
.br
	    db_group = ipacct
.br
	    db_dir = /var/db/ipa
.br
	    lock_wait_time = 20s
.br
	}
.PP
Давайте проверим этот пример. \fBmaxchunk\fP равен 10 Мбайтам и
\fBupdate_db_time\fP равно 30 секундам. \fBmaxchunk\fP / \fBupdate_db_time\fP
равно 2,7\ Мбит/с. Это нормальное значения для линии со скоростью 115\ кбит/с,
но не достаточно для Ethernet 10\ Мбит. Директория базы данных изменена и будет
создана \fBipa\fP(8), если она ещё не существует.
.PP
Параметр \fBinfo\fP в секции \fBrule\fP позволяет дать описание для правила.
Если описание для правила задано, то оно будет выводится программой
\fBipastat\fP(8).
.PP
Параметр \fBinfo\fP имеет следующий формат:
.PP
	info = <строка>
.PP
<Строка> должна быть не пустой последовательностью символов.
.PP
Пример:
.PP
	info = Суммарный трафик для ISP
.br
	info = Исходящий трафик пользователя simon
.PP
Последующие секции позволяют запускать команды, если счётчик правила достигнет
определённого значения и не только это.
.PP
Значения счётчика байтов правила может быть проверено в секции \fBlimit\fP.
.PP
Секция \fBlimit\fP имеет следующий формат:
.PP
	limit <имя-лимита> {
.br
	# параметры и другие секции
.br
	}
.PP
<Имя-лимита> это строка без пробельных символов, символов `{', `}', `#'
и символа `;'. Следует указывать такое имя
для лимита, которое также является доступным именем для директории в вашей
операционной/файловой системе, так как каждый лимит представляется директорией
в базе данных.
.PP
Секция \fBlimit\fP должна располагаться в секции \fBrule\fP. В секции \fBrule\fP
может быть несколько секций \fBlimit\fP, но все секции \fBlimit\fP должны
иметь имена. Имя лимита позволяет свободно удалять и добавлять секции
\fBlimit\fP в секцию \fBrule\fP (лимиты различаются по именам, а не по порядку,
как они записаны). Секция \fBlimit\fP должна иметь по крайне мере один
параметр \fBbyte_limit\fP (или \fBbytes_limit\fP).
.PP
Параметр \fBbyte_limit\fP в секции \fBlimit\fP определяет количество байтов,
при котором лимит считается достигнутым.
.PP
Параметр \fBbyte_limit\fP имеет следующий формат:
.PP
	byte_limit = <размер>
.PP
Где <размер> имеет такой же формат что и параметр \fBmaxchunk\fP. Текущие
значения счётчиков лимитов сохраняются в базе данных, и используется при старте
\fBipa\fP(8) и может быть просмотрено при помощи программы \fBipastat\fP(8).
\fINOTE\fP: счётчики лимитов обновляются каждые \fBupdate_db_time\fP секунд.
.PP
Секция \fBlimit\fP может иметь параметры \fBinfo\fP и \fBworktime\fP, которые
обозначают тоже самое, что и эти же параметры в секции \fBrule\fP. Если
параметр \fBworktime\fP не указан, то используется значение одноимённого
параметра из секции \fBrule\fP. Если тот параметр также не указан, то
используется этот же параметр из секции \fBglobal\fP. Если и тот параметр не
указан, тогда лимит действует для всех дней. \fINOTE\fP: не требуется чтобы
значение параметра \fBworktime\fP в секции \fBlimit\fP было таким же как и
в секции \fBrule\fP, обычно значение параметра \fBworktime\fP в секции
\fBlimit\fP является подмножеством значения параметра \fBworktime\fP в
секции \fBrule\fP.
.PP
Параметр \fBworktime\fP в секции \fBlimit\fP означает, что счётчик байтов
лимита должен вычисляться только в указанные периоды времени.
Этот параметр влияет на параметры \fBzero_time\fP и \fBexpire_time\fP,
т.е., если учёт трафика для лимита не разрешён, тогда время, когда лимит должен
быть обнулён или должен быть перезапущен игнорируется, до тех пор, пока
лимит не станет опять активным. Если параметр \fBworktime\fP в секции
\fBrule\fP не разрешает вести учёт трафика для какого-то периода времени,
то параметр \fBworktime\fP в секции \fBlimit\fP игнорируется.
.PP
Текущее значение счётчика байтов лимита может быть обнулено. Т.е. можно
указать время через которое лимит будет считаться устаревшим. Для этого можно
воспользоваться параметром \fBzero_time\fP в секции \fBlimit\fP.
.PP
Параметр \fBzero_time\fP имеет следующий формат:
.PP
	zero_time = [+<X>] <время2>
.br
	zero_time = <время2> [+<X>]
.PP
Параметр \fBzero_time\fP в секции \fBlimit\fP определяет время когда счётчик
байтов лимита должен быть обнулён. Значение этого параметра добавляется к
времени старта счётчика лимита. Формат для <время2> похож на формат
<время>. Так же как и в формате <время> символ `\fBs\fP' обозначает секунды,
`\fBm\fP' - минуты, `\fBh\fP' - часы. Но добавлены несколько дополнительных
модификаторов: символ `\fBd\fP' или `\fBD\fP' обозначает дни, `\fBw\fP' или
`\fBW\fP' - недели (7 дней), `\fBM\fP' - месяца (\fINOTE\fP: `\fBm\fP' и
`\fBM\fP' это не одно и тоже). Если величина <время2> определена как
составная величина, то месяца должны предшествовать неделям, дням, часам,
минутам, секундам и т.д.
.PP
Для <X> допустимы следующие значения: `\fBm\fP', `\fBh\fP', `\fBd\fP',
`\fBD\fP', `\fBw\fP', `\fBW\fP', `\fBM\fP'. Смотрите следующие примеры для
понимания их значения.
.PP
Пример:
.PP
	zero_time = 1d 20h
.br
	zero_time = 1M 30d
.br
	zero_time = +W
.br
	zero_time = 1w 10h +M
.br
	zero_time = +M 1w 10h
.PP
Первый пример определяет, что байтовый счётчик лимита должен быть обнулён через
1 день и 20 часов после своего старта. Второй пример определяет, что байтовый
счётчик лимита должен быть обнулён через 1 месяц и 30 дней после своего старта.
30 дней добавляется к времени когда счётчик
лимита стартовал, затем к полученному времени "добавляется" 1 месяц. Например,
если <старт> + 30\ дней = 10\ Янв\ 2000, тогда <старт> + 30\ дней + 1\ месяц =
10\ Фев\ 2000; если <старт> + 30\ дней = 31\ Янв\ 1999, тогда
<старт> + 30\ дней + 1\ месяц = 28\ Фев\ 1999 (т.е. может быть не тот же
самый день в месяце). Третий пример определяет что байтовый счётчик лимита
должен быть обнулён в конце той недели, когда он был запущен. Четвёртый
пример более сложен. 1 неделя и 10 часов добавляются к времени старта счётчика
лимита, затем счётчик лимита будет обнулён в конце месяца полученной даты.
Пятый пример определяет, что байтовый счётчик лимита должен быть обнулён
через 1 неделю и 10 часов после конца текущего месяца. \fINOTE\fP: четвёртый
и пятый примеры это не одно и тоже и дают разные результаты.
.PP
\fINOTE\fP: первый день недели - понедельник.
.PP
Если байтовый счётчик лимита достигает значения \fBbyte_limit\fP, то
\fBipa\fP(8) сообщает об этом в syslog если значение параметра
\fBdebug_limit\fP больше чем 0 и последующее поведение \fBipa\fP(8) зависит
следующих параметров и секций.
.PP
Вы можете определить команды в секции \fBreach\fP, которые будут запускаться,
если байтовый счётчик лимита достигнет значения \fBbyte_limit\fP. Секция
\fBreach\fP может быть записана только в секции \fBlimit\fP и может иметь 
только один тип параметра: \fBexec\fP.
.PP
Параметр \fBexec\fP имеет следующий формат:
.PP
	exec = <командная-строка>
.br
	exec(<пользователь>) = <командная-строка>
.br
	exec(<пользователь>:) = <командная-строка>
.br
	exec(<пользователь>:<группа>) = <командная-строка>
.br
	exec(:<группа>) = <командная-строка>
.PP
Рассмотрим примеры:
.PP
	0. exec = /some/command
.br
	1. exec(simon) = /some/command
.br
	2. exec(simon:nobody) = /some/command
.br
	3. exec(1000) = /some/command
.br
	4. exec(simon:1001) = /some/command
.br
	5. exec(:nobody) = /some/command
.br
	6. exec(1234:) = /some/command
.br
	7. exec(:9876) = /some/command
.br
	8. exec(1234:9876) = /some/command
.PP
"simon" это зарегистрированный пользователь с UID 1000.
"nobody" это зарегистрированная группа с GID 1001.
"1234" не является зарегистрированным пользователем и нет ни одного
пользователя с таким UID в файле /etc/passwd.
"9876" не является зарегистрированной группой и нет ни одной группы с
таким GID в файле /etc/group.
.PP
0. Команда запускается с правами супер-пользователя и обычно с правами группы
супер-пользователя, с правами дополнительных групп супер-пользователя.
.PP
1. Команда запускается с правами пользователя "simon" и с правами группы
пользователя "simon", с правами дополнительных групп пользователя "simon".
.PP
2. Этот пример похож на первый, но добавлена дополнительная группа "nobody".
Команда запускается с правами пользователя "simon" и с правами группы
"nobody", с правами группы и дополнительных групп пользователя "simon" (в
действительности группа и дополнительные группы пользователя "simon"
становятся дополнительными группами для нового процесса). Таким образом, в этом
случае добавлены дополнительные права пользователю "simon" (дополнительные
права это права группы "nobody").
.PP
3. Этот пример похож на первый, так как UID пользователя "simon" равен 1000.
Но вам следует использовать имя пользователя вместо UID, если вы имеете в виду
реальное имя из файла /etc/passwd.
.PP
4. Этот пример похож на второй, так как GID группы "nobody" равен 1001. Но
вам следует использовать имя группы вместо GID, если вы имеете в виду реальную
группу из файла /etc/group.
.PP
5. Команда запускается с правами супер-пользователя (от имени того
пользователя, который может запускать \fBipa\fP(8)) и с правами группы
"nobody", с правами группы и дополнительных групп супер-пользователя.
.PP
6. Команда запускается с правами пользователя с UID 1234 и обычно с правами
группы супер-пользователя и с правами дополнительных групп супер-пользователя.
.PP
7. Этот пример похож на пятый пример, но группа задана при помощи GID 9876.
.PP
8. Команда запускается с правами пользователя с UID 1234 и с правами группы с
GID 9876.
.PP
\fINOTE\fP: параметры подобно exec(1234), где 1234 не является
зарегистрированным пользователем и нет пользователя с таким UID в файле
/etc/passwd, не допускаются, так как \fBipa\fP(8) не знает что делать с
дополнительными группами такого пользователя. \fINOTE\fP: не используйте
параметры exec(<пользователь>:), так как команды в таких параметрах наследуют
права дополнительных групп пользователя запустившего программу \fBipa\fP(8), до
тех пор пока вы не осознаете зачем и почему вы это должны делать.
.PP
\fINOTE\fP: иногда в приведенных примерах использовалось слово "обычно".
\fBipa\fP(8) может быть запущена только супер-пользователем, но группа
запущенной копии \fBipa\fP(8) может быть не равна группе супер-пользователя.
.PP
<Командная-строка> это не пустая последовательность символов. Каждая
<командная-строка> запускается при помощи функции system(3), поэтому доступны
конвейеры shell, перенаправление вывода и т.п. По умолчанию \fBipa\fP(8)
воспринимает команды, заданные с абсолютными путевыми именами. Если вам это
не нравится и вы хотите использовать команды, которые командный интерпретатор
\fBsh\fP(1) найдёт для вас основываясь на переменной shell \fB$PATH\fP
(\fBsh\fP(1) запускается из функции system(3)), тогда установите параметр
\fBonly_abs_paths\fP в "\fBno\fP" в секции \fBglobal\fP. \fINOTE\fP: не
рекомендуется устанавливать параметр \fBonly_abs_paths\fP в "\fBno\fP", так
как переменная shell \fB$PATH\fP понижает безопасность.
.PP
Когда команда, указанная в параметре \fBexec\fP, запускается, \fBipa\fP(8)
перенаправляет стандартный ввод (stdin), стандартный вывод (stdout) и
стандартный вывод ошибок (stderr) в /dev/null, но всё равно можно использовать
перенаправление вывода shell (например ">", ">>", "<", "<<", и т.п.).
.PP
В секции \fBreach\fP может быть указано несколько параметров \fBexec\fP, это
обозначает последовательность команд. Все команды запускаются в потомке
\fBipa\fP(8), т.е. \fBipa\fP(8) запускает их в фоновом режиме. Если
\fBipa\fP(8) запустила команды в фоновом режиме, то  \fBipa\fP(8) ожидает
завершения работы своего потомка и только после наступления этого события
продолжает работу с лимитом. Если вы определили команды, время выполнения
которых может занять некоторое время (минуты, часы и т.д.), программа
\fBipastat\fP(8) выведет информацию об этом. \fINOTE\fP: если вы думаете что
\fBipa\fP(8) неправильно запускает ваши команды или работает не должным
образом, пожалуйста, проверьте вывод \fBipastat\fP(8) и убедитесь, что все
команды для лимита завершили свою работу (используйте опции \fB-r\fP и
\fB-l\fP).
.PP
Пример:
.PP
	reach {
.br
	    exec = /sbin/ipfw \(rs
.br
		add 100 deny all from 10.1.1.1 to 10.123.1.2
.br
	    exec = /sbin/ipfw \(rs
.br
		add 101 deny all from 10.1.1.1 to 10.123.1.3
.br
	}
.PP
Имеется возможность определить время, когда достигнутый лимит будет считаться
истекшим. Для этого может быть использована секция \fBexpire\fP в секции
\fBlimit\fP. Секция \fBexpire\fP должна иметь по крайней мере один параметр
\fBexpire_time\fP. Параметр \fBexpire_time\fP в секции \fBexpire\fP определяет
когда лимит будет считаться истекшим и будет перезапущен. Формат для параметра
\fBexpire_time\fP в секции \fBexpire\fP аналогичен формату параметра
\fBzero_time\fP в секции \fBlimit\fP. Также имеется возможность определить
команды, которые должны быть запущены, когда достигнутый лимит будет
перезапускаться. Для этого можно воспользоваться параметрами \fBexec\fP.
.PP
Пример:
.PP
	expire {
.br
	    expire_time = +w
.br
	    exec = /sbin/ipfw del 100
.br
	    exec = /sbin/ipfw del 101
.br
	}
.PP
Аналогично ситуации с параметрами в секции \fBreach\fP, параметры \fBexec\fP
в секции \fBexpire\fP запускаются в фоновом режиме. Все замечания для
параметров \fBexec\fP в секции \fBreach\fP являются актуальными для параметров
\fBexec\fP в секции \fBexpire\fP.
.PP
Параметры \fBexec\fP в секциях \fBreach\fP и \fBexpire\fP могут быть не
указаны. Это не ошибка и \fBipa\fP(8) просто остановит счётчик лимита и
перезапустит лимит, но вероятно вы захотите сделать некоторые действия когда
лимит достигнет некоторого значения или достигнутый лимит будет перезапущен.
.PP
Секцию \fBlimit\fP можно использовать для контроля средней пропускной
способности. Предположим необходимо контролировать среднюю пропускную
способность в 10\ кбайт/с для какого-то множества правил IPFW/IPF/PF. Один
из возможных путей решения: установить \fBbyte_limit\fP в 1000k и установить
\fBzero_time\fP в 100s. \fBbyte_limit\fP\ /\ \fBzero_time\fP равно 10\ кбайт/с.
Также необходимо записать команды в секциях \fBreach\fP и \fBexpire\fP чтобы
реально сделать что-то когда средняя пропускная способность будет больше чем
10\ кбайт/с. Заметьте, что мы не установили \fBbyte_limit\fP в 10k и
\fBzero_time\fP в 1s, так как необходимо контролировать среднюю пропускную
способность в течении более длительного периода времени чем 1 секунда и
позволить использовать пропускную способность большую чем 10\ кбайт/с.
.PP
Секции \fBlimit\fP работают так как это было описано только тогда, когда
\fBipa\fP(8) запущена. Когда \fBipa\fP(8) запускается или находит
непоследовательные изменения в датах или во времени и когда лимиты уже имеют
соответствующие файлы в базе данных, тогда секции \fBlimit\fP работают немного
по другому.
.PP
Когда \fBipa\fP(8) стартует и находит что файл статистики для какого-то лимита
уже существует, то:
.PP
1. Если лимит не достигнут со старым значением параметра \fBbyte_limit\fP,
тогда \fBipa\fP(8) модифицирует старое значение параметра \fBbyte_limit\fP в
файле статистики для этого лимита, если старое значение не равно текущему;
пересчитывает и обновляет время когда лимит должен будет обнулён, если
определён параметр \fBzero_time\fP; если только что обновлённое время обнуления
лимита меньше чем текущее время, то \fBipa\fP(8) перезапускает лимит.
.PP
2. Если лимит достигнут со старым значением параметра \fBbyte_limit\fP, тогда
если старое значение времени когда лимит должен быть перезапущен меньше
текущего времени, то \fBipa\fP(8) перезапускает лимит; дальше \fBipa\fP(8)
обновляет время когда лимит должен быть перезапущен основываясь на текущем
значении параметра \fBexpire_time\fP, если он определён для этого лимита; если
только что обновлённое значение времени когда лимит должен быть перезапущен
меньше чем текущее время, то \fBipa\fP(8) перезапускает лимит.
.PP
Когда \fBipa\fP(8) обнаруживает непоследовательные изменения в дате или во
времени, тогда делаются те же самые шаги по проверке лимитов, но лимиты не
перезапускаются. Это позволяет запускать команды в секции \fBexpire\fP.
.PP
Секции \fBstartup\fP и \fBshutdown\fP реализованы для запуска команд во время
старта или останова \fBipa\fP(8). Эти секции могут содержать только один тип
параметра: \fBexec\fP.
.PP
В секции \fBstartup\fP вы можете указать команды, которые должны запускаться
во время старта \fBipa\fP(8). Аналогично в секции \fBshutdown\fP вы можете
определить команды, которые должны запускаться когда \fBipa\fP(8) завершает
свою работу.
.PP
Пример:
.PP
	startup {
.br
	    exec = /sbin/ipfw add 100 allow all\(rs
.br
	              from 10.1.2.3 to any
.br
	    exec = /some-path/set-ipfil-rules
.br
	    exec(simon) = /home/dir/simon/some-user-program
.br
	}
.br
	shutdown {
.br
	    exec = /sbin/ipfw add 90 deny all\(rs
.br
	              from 10.1.2.3 to any
.br
	    exec = /some-path/block-ipfil-rules
.br
	}
.PP
Секции \fBstartup\fP и \fBshutdown\fP могут располагаться отдельно (подобно
секциям \fBglobal\fP и \fBrule\fP), могут быть включены в секции \fBrule\fP и
\fBlimit\fP. Но существует одно различие. Команды в параметрах \fBexec\fP из
секции \fBstartup\fP не включённой ни в одну из секций выполняются в первую
очередь. Затем \fBipa\fP(8) запускает команды в параметрах \fBexec\fP из секции
\fBstartup\fP, включённой в секцию \fBrule\fP. И только затем \fBipa\fP(8)
запускает команды в параметрах \fBexec\fP из секции \fBstartup\fP, включённой
в секцию \fBlimit\fP. \fINOTE\fP: \fBipa\fP(8) работает с секциями \fBrule\fP и
\fBlimit\fP в порядке их следования в конфигурационном файле. Команды в
параметрах \fBexec\fP из секций \fBshutdown\fP запускаются в обратном порядке:
первыми \fBipa\fP(8) запускает команды в \fBexec\fP параметрах из секции
\fBshutdown\fP из секции \fBrule\fP, затем из секции \fBlimit\fP и только затем
из секции \fBshutdown\fP расположенной отдельно.
.PP
Секции \fBstartup\fP и \fBshutdown\fP, включённые в секции \fBrule\fP и
\fBlimit\fP, могут иметь дополнительные секции: \fBif_limit_is_reached\fP и
\fBif_limit_is_not_reached\fP. Секции \fBif_limit_is_reached\fP и
\fBif_limit_is_not_reached\fP могут иметь только один тип параметра:
\fBexec\fP. Существуют короткие формы названий этих секций:  \fBif_limit\fP,
\fBif_limit_reached\fP, и \fBif_nolimit\fP, \fBif_limit_not_reached\fP.
.PP
Секция \fBif_limit_is_reached\fP определяет команды, которые должны быть
запущены во время старта или останова (в зависимости от типа внешней секции)
\fBipa\fP(8) если лимит достигнут. Секция \fBif_limit_is_not_reached\fP
определяет команды, которые должны быть запущены во время старта или останова
(в зависимости от типа внешней секции) \fBipa\fP(8) если лимит не достигнут.
Если внешняя секция \fBstartup\fP или \fBshutdown\fP расположена в секции
\fBrule\fP, то "лимит" рассматривается как "любой из лимитов". Если внешняя
секция \fBstartup\fP или \fBshutdown\fP расположена в секции \fBlimit\fP, то
"лимит" рассматривается как "лимит текущей секции \fBlimit\fP".
.PP
\fINOTE\fP: все команды в параметрах \fBexec\fP из секций \fBstartup\fP и
\fBshutdown\fP выполняются в процессе старта \fBipa\fP(8), а все команды в
параметрах \fBexec\fP из секций \fBreach\fP и \fBexpire\fP выполняются в
фоновом режиме.
.PP
Секция \fBdebug\fP позволяет отлаживать конфигурационный файл и работу
\fBipa\fP(8). Эта секция состоит только из параметров. Имеется возможность
определить несколько режимов у уровней отладки.
.PP
Секция \fBdebug\fP имеет следующий формат:
.PP
	debug {
.br
	    debug_ipfw = <уровень>
.br
	    debug_ip6fw = <уровень>
.br
	    debug_ipfil = <уровень>
.br
	    debug_pf = <уровень>
.br
	    debug_exec = <уровень>
.br
	    debug_limit = <уровень>
.br
	    debug_time = <уровень>
.br
	    debug_worktime = <уровень>
.br
	    debug_lock = <уровень>
.br
	    debug_include = <уровень>
.br
	}
.PP
По умолчанию <уровни> для всех режимов отладки равны 0, это означает, что
отладка отключена. Параметр \fBdebug_ipfw\fP или \fBdebug_ip4fw\fP используется
для отладки FreeBSD IPv4 Firewall, \fBdebug_ip6fw\fP используется для отладки
FreeBSD IPv6 Firewall, \fBdebug_pf\fP используется для отладки OpenBSD Packet
Filter, \fBdebug_ipfil\fP используется для отладки IP Filter,
\fBdebug_exec\fP используется для отладки параметров \fBexec\fP,
\fBdebug_limit\fP используется для отладки секций \fBlimit\fP и \fBexpire\fP.
\fBdebug_time\fP используется для отладки различных временных интервалов,
\fBdebug_worktime\fP используется для отладки параметров \fBworktime\fP
и параметр \fBdebug_lock\fP используется для отладки блокировки базы данных и
файлов базы данных. \fBdebug_include\fP используется для регистрации информации
в syslogd(8) о файлах и директориях, включённых \fBipa\fP(8) в общую
конфигурацию (см. документацию на секцию \fBinclude\fP ниже). Чтобы получить
больше отладочной информации следует увеличить значение <уровня> (максимальное
значение уровня отладки равно 3).
.PP
Уровень параметра \fBdebug_include\fP по умолчанию равен 1, это означет, что
\fBipa\fP(8) будет сообщать о всех включаемых файлах и директориях, если
вы хотите видеть также имена не включённых файлов и директорий (например, те
файлы в директориях, имена которых не совпадают с соответствующим регулярными
выражениями), то вам следует установить уровень для этого параметра в 2. Чтобы
остановить сообщения о включаемых файлах и директориях, установите уровень для
параметра \fBdebug_include\fP в 0. \fINOTE\fP: когда конфигурационные файлы
проверяются \fBipa\fP(8) с ключами \fB-tt\fP, то \fBipa\fP(8) всегда сообщает о
включённых и не включённых файлах и директориях.
.PP
Секция \fBinclude\fP позволяет хранить конфигурационную информацию в нескольких
файлах.
.PP
Секция \fBinclude\fP имеет следующий формат:
.PP
	include {
.br
	    file = <файл>
.br
	    file(?) = <файл>
.br
	    files(<директория>) = <регулярное-выражение>
.br
	    files(?)(<директория>) = <регулярное-выражение>
.br
	}
.PP
Параметр \fBfile\fP позволяет включить один файл. Если после параметра
\fBfile\fP указаны символы "\fB(?)\fP" и <файл> не существует в файловой системе,
то \fBipa\fP(8) не будет паниковать об этом, пропустит этот файл и продолжит
обрабатывать текущий конфигурационный файл.
.PP
Параметр \fBfiles\fP позволяет включить несколько файлов из <директории> и
каждый включённый файл должен совпадать с <регулярным-выражением>.
<регулярное-выражение> это не маска shell, оно должно соответствовать формату
регулярных выражений POSIX \fBre_format\fP(7). Если после параметра \fBfiles\fP
указаны символы "\fB(?)\fP" и <директория> не существует в файловой системе, то
\fBipa\fP(8) не будет паниковать об этом, пропустит эту <директорию> и продолжит
обрабатывать текущий конфигурационный файл.
.PP
Секции \fBinclude\fP могут быть размещены в нескольких конфигурационных файлах,
но каждый очередной параметр \fBfiles\fP или \fBfile\fP будет определять
файл(ы), которые будут включаться после включения всех предыдущих файлов.
.PP
Каждый включаемый файл должен иметь корректный формат. Т.е. нельзя начать
что-то в одном файле и завершить в другом.
.PP
Пример:
.PP
	include {
.br
	    file = /usr/local/etc/ipa/myaccout
.br
	    file(?) = /usr/local/etc/ipa/mytestaccount
.br
	    files(/usr/local/etc/ipa/192.168.0) = .
.br
	    files(/usr/local/etc/ipa/10.1) = ^(2|11)\\.*
.br
	    files(?)(/usr/local/etc/ipa/testconfig) = \\.conf$
.br
	}
.PP
Первый параметр \fBfile\fP указывает \fBipa\fP(8) включить файл
/usr/local/etc/ipa/myaccout. Второй параметр \fBfile\fP также указывает
включить один файл, но если файл /usr/local/etc/ipa/mytestaccount не существует
в файловой системе, то \fBipa\fP(8) его проигнорирует.
.PP
Первый параметр \fBfiles\fP "включает" все файлы из директории
/usr/local/etc/ipa/192.168.0. Второй параметр \fBfiles\fP "включает" все
файлы, которые соответствуют данному регулярному выражению POSIX, из директории
/usr/local/etc/ipa/10.1. И последний параметр \fBfiles\fP "включает" все файлы
с суффиксом ".conf" из директории /usr/local/etc/ipa/testconfig, но если эта
директория отсутствует в файловой системе, то \fBipa\fP(8) проигнорирует её
и продолжит работу.
.PP
\fBipa\fP(8) делает те же самые проверки для всех включаемых файлов, как и для
конфигурационного файла, заданного по умолчанию. Директории в параметрах
\fBfiles\fP должны иметь владельца супер-пользователя и не должны иметь прав
на запись для группы и для остальных пользователей.
.PP
Когда \fBipa\fP(8) запускается с ключами \fB-tt\fP, то \fBipa\fP(8) включает
все конфигурационные файлы из секции(й) \fBinclude\fP и выводит их содержимое
как один конфигурационный файл. В этом случае \fBipa\fP(8) также выводит
всю информацию о включённых и невключённых файлах и директориях в комметариях.
Где:
.PP
\fB[+]\fP\ -\ файл был включён;
.br
\fB[n]\fP\ -\ файл не существует и были указаны символы "\fB(?)\fP" после
соответствующего параметра \fBfile\fP;
.br
\fB<+>\fP\ -\ директория существует и \fBipa\fP(8) просканирует её;
.br
\fB<n>\fP\ -\ директория не существует и были указаны символы "\fB(?)\fP" после
соответствующего параметра \fBfiles\fP;
.br
\fB[!]\fP\ -\ имя файла не соответствует регулярному выражению в соответствующем
параметре \fBfiles\fP;
.br
\fB[i]\fP\ -\ файл был уже включён (проверьте свою конфигурацию, вы включаете
один и тот же файл два или более количество раз).
.PP
\fBipa\fP(8) может перечитать конфигурационный файл, но не все изменения будут
иметь эффект. \fBipa\fP(8) не запустит ни одну команду из секций \fBstartup\fP,
но новые значения параметров \fBexec\fP из секций \fBshutdown\fP будут иметь
эффект.
.SH EXAMPLES
См. директорию ${PREFIX}/share/examples/ipa/ с примерами.
.SH TEMPLATE
Это шаблон для конфигурационного файла. Это не пример, но может быть полезен в
понимании того, что и где следует расположить.
.PP
global {
.br
    update_db_time = <время>
.br
    append_db_time = <время>
.br
    maxchunk = <размер>
.br
    db_dir = <путь>
.br
    db_group = <группа>
.br
    worktime = <временной-интервал>
.br
    lock_db = <boolean>
.br
    lock_wait_time = <время>
.br
    only_abs_paths = <boolean>
.br
}
.PP
debug {
.br
    debug_ipfw = <уровень>
.br
    debug_ip6fw = <уровень>
.br
    debug_ipfil = <уровень>
.br
    debug_pf = <уровень>
.br
    debug_exec = <уровень>
.br
    debug_limit = <уровень>
.br
    debug_time = <уровень>
.br
    debug_worktime = <уровень>
.br
    debug_lock = <уровень>
.br
    debug_include = <уровень>
.br
}
.PP
include {
.br
    file = <файл>
.br
    file(?) = <файл>
.br
    files(<директория>) = <регулярное-выражение>
.br
    files(?)(<директория>) = <регулярное-выражение>
.br
}
.PP
startup {
.br
    exec = <командная-строка>
.br
    exec(<пользователь>) = <командная-строка>
.br
}
.PP
shutdown {
.br
    exec = <командная-строка>
.br
    exec(<пользователь>) = <командная-строка>
.br
}
.PP
rule <имя-правила> {
.br
    ipfw = <список-правил-ipfw>
.br
    ip6fw = <список-правил-ip6fw>
.br
    ipfil = <список-правил-ipfil>
.br
    pf = <список-правил-pf>
.br
    update_db_time = <время>
.br
    append_db_time = <время>
.br
    db_group = <группа>
.br
    info = <строка>
.br
    maxchunk = <размер>
.br
    worktime = <временной-интервал>
.br
    startup {
.br
        exec = <командая-строка>
.br
        exec(<пользователь>) = <командная-строка>
.br
        if_limit_is_reached {
.br
            exec = <командная-строка>
.br
            exec(<пользователь>) = <командная-строка>
.br
        }
.br
        if_limit_is_not_reached {
.br
            exec = <командная-строка>
.br
            exec(<пользователь>) = <командная-строка>
.br
        }
.br
    }
.br
    shutdown {
.br
        exec = <командная-строка>
.br
        exec(<пользователь>) = <командная-строка>
.br
        if_limit_is_reached {
.br
            exec = <командная-строка>
.br
            exec(<пользователь>) = <командная-строка>
.br
        }
.br
        if_limit_is_not_reached {
.br
            exec = <командная-строка>
.br
            exec(<пользователь>) = <командная-строка>
.br
        }
.br
    }
.br
    limit <имя-лимита> {
.br
        byte_limit = <размер>
.br
        zero_time = [+<X>] [<время2>]
.br
        zero_time = [<время2>] [+<X>]
.br
        info = <строка>
.br
        worktime = <временной-интервал>
.br
        reach {
.br
            exec = <командная-строка>
.br
            exec(<пользователь>) = <командная-строка>
.br
        }
.br
        expire {
.br
            expire_time = [+<X>] [<время2>]
.br
            expire_time = [<время2>] [+<X>]
.br
            exec = <командная-строка>
.br
            exec(<пользователь>) = <командная-строка>
.br
        }
.br
        startup {
.br
            exec = <командная-строка>
.br
            exec(<пользователь>) = <командная-строка>
.br
            if_limit_is_reached {
.br
                exec = <командная-строка>
.br
                exec(<пользователь>) = <командная-строка>
.br
            }
.br
            if_limit_is_not_reached {
.br
                exec = <командная-строка>
.br
                exec(<пользователь>) = <командная-строка>
.br
            }
.br
        }
.br
        shutdown {
.br
            exec = <командная-строка>
.br
            exec(<пользователь>) = <командная-строка>
.br
            if_limit_is_reached {
.br
                exec = <командная-строка>
.br
                exec(<пользователь>) = <командная-строка>
.br
            }
.br
            if_limit_is_not_reached {
.br
                exec = <командная-строка>
.br
                exec(<пользователь>) = <командная-строка>
.br
            }
.br
        }
.br
    }
.br
#   ... другие секции limit.
.br
}
.br
# ... другие секции rule.
.SH FILES
/usr/local/etc/ipa.conf
.br
${PREFIX}/etc/ipa.conf.default
.br
${PREFIX}/share/examples/ipa/
.PP
(по умолчанию ${PREFIX} это /usr/local)
.SH SEE ALSO
ipa(8), ipa(5), ipastat(8), ipf(1), ipf(5), ipfstat(8), ipfw(8), ip6fw(8),
pf.conf(5), pfctl(8)
.SH AUTHOR
Andrey\ Simonenko\ <simon@comsys.ntu-kpi.kiev.ua>
.SH BUGS
Если вы обнаружите какие-либо ошибки, то, пожалуйста, сообщите мне по email.
